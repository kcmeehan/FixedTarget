//xianglei's analysis macro: analyze the picoDST generated by StMcV0Maker. 

#ifndef __CINT__
#include "TROOT.h"
#include "TMath.h"
#include "TSystem.h"
#include "TApplication.h"
#include "TFile.h"
#include "TError.h"
#include "TTree.h"
#include "TChain.h"
#include "TH1.h"
#include "TH2.h"
#include "TF1.h"
#include "TStyle.h"
#include "TCanvas.h"
#include "TString.h"
#include "Riostream.h"
#include <sstream>
#include <string>
#include <cstdlib>
#include "StThreeVectorF.hh"
#include "StPhysicalHelixD.hh"
//#include "StRefMultCorr/CentralityMaker.h"
//#include "StRefMultCorr/StRefMultCorr.h"

#include "v0dst.h"
TChain* ChainThem(const char* filelist, const char* treename, int nlist, int block);
#endif

//groups of runs
const int kGroup   = 1;
Double_t grpbd[kGroup+1]={0,17000000.};

//centrality bin for strangeness analysis: 30-80%,10-30%,0-10%
//const int kCentBin = 1;
//Float_t  centbd[kGroup][kCentBin+1]={{-0.5,8.5}};
//const int kCentBin = 3;
//Float_t  centbd[kGroup][kCentBin+1]={{-0.5,4.5,6.5,8.5}};
//centrality bin for strangeness analysis: 60-80%,40-60%,30-40%,20-30%,10-20%,5-10%,0-5%
const int kCentBin = 6;
Float_t  centbd[kGroup][kCentBin+1]={{48,61,77,97,121,153,500}};

//const int kPtBin = 13;
//Float_t  ptbd[kPtBin+1]={0.2,0.4,0.6,0.8,1.0,1.2,1.4,1.6,1.8,2.0,2.5,3.0,3.5,4.0};
//const int kPtBin = 19;
//Float_t  ptbd[kPtBin+1]={0.2,0.4,0.6,0.8,1.0,1.2,1.4,1.6,1.8,2.0,2.2,2.4,2.6,2.8,3.0,3.2,3.4,3.6,3.8,4.0};
//const int kPtBin = 16;
//Float_t  ptbd[kPtBin+1]={0.2,0.4,0.6,0.8,1.0,1.2,1.4,1.6,1.8,2.0,2.5,3.0,3.5,4.0,5.0,6.0,8.0};
const int kPtBin = 12;
Float_t  ptbd[kPtBin+1]={0.2,0.4,0.6,0.8,1.0,1.2,1.4,1.6,1.8,2.0,2.3,2.8,3.5};

int funcswitch;
Double_t getWeight(Int_t cent, Float_t pt, int expswitch);

//parameterize levy function to supply the weight
//TF1 funclowpt("levy1","x*(([0]*([1]-1)*([1]-2))/([1]*[2]*([1]*[2]+0.497614*([1]-2))))/(1+((TMath::Sqrt((x*x)+(0.497614*0.497614))-0.497614)/([1]*[2])))^[1]",0.,10.0);
//const int kParms=3;
//Double_t fitparms[kCentBin*kParms]={1.05894e-07,28.6315,0.186147,4.05935e-06,34.3852,0.20217,8.71666e-05,40,0.212554,0.00137865,40,0.215449,0.0210901,40,0.21728,0.284124,40,0.218147,3.4973,40,0.218565};
static TF1 funclowpt("mtexp","x*[0]*exp(-sqrt(x**2+0.497614**2)/[1])",0.,10.);
const int kParms=2;
Double_t fitparms[kCentBin*kParms]={0.000202214,0.197591,0.0037396,0.207424,0.0556371,0.211572,0.778225,0.216191,9.72326,0.219686,118.169,0.221269};

//parameterize levy function to supply the weight
//TF1 funchighpt("levy","x*(([0]*([1]-1)*([1]-2))/([1]*[2]*([1]*[2]+0.497614*([1]-2))))/(1+((TMath::Sqrt((x*x)+(0.497614*0.497614))-0.497614)/([1]*[2])))^[1]",0.,10.0);
//const int kParms2=3;
//Double_t fitparms2[kCentBin*kParms2]={1.05893e-07,28.6326,0.186148,4.05935e-06,34.3865,0.202171,8.6615e-05,43.6186,0.214672,0.00138604,41.4942,0.21571,0.0219658,44.6702,0.217069,0.296443,47.9322,0.218879,3.68459,54.7622,0.220758};
static TF1 funchighpt("mtexp1","x*[0]*exp(-sqrt(x**2+0.497614**2)/[1])",0.,10.);
const int kParms2=2;
Double_t fitparms2[kCentBin*kParms2]={0.000202214,0.197591,0.0037396,0.207424,0.0556371,0.211572,0.778225,0.216191,9.72326,0.219686,118.169,0.221269};

void cuts_ks_cut0(int nlist, int block, int expswitch, int fswitch){

//the following will be loaded in .rootlogon.C in ACLIC mode
#ifdef __CINT__  
   //gSystem->Load("StRefMultCorr");
   gROOT->LoadMacro("TChainTool.C+");
   gROOT->LoadMacro("v0dst.C+");
#endif

   funcswitch = fswitch;
   char funcname[][10]={"high","low"};
   cout<<"Weighting with fitting functions for the "<<funcname[fswitch]<<" pT spectra!"<<endl;

   //StRefMultCorr* refmultCorrUtil = CentralityMaker::instance()->getRefMultCorr() ;

   TChain * t = NULL;
   if(!expswitch){
	t = ChainThem("k0sfp_100_129.pico.list","McV0PicoDst",nlist,block);
   }
   else{
	t = ChainThem("k0sexp_100_119.pico.list","McV0PicoDst",nlist,block);
   }
   if(!t){ cout<<"ERROR: no files are added to the chain!"<<endl; return; }

   //bound them together
   v0dst dst(t);

   //input parameters for fit functions
   ifstream parms(Form("input/auau5_ks_fit_cut0_%s.txt",funcname[fswitch]));
   if(parms){
	cout<<"READING function parameters from data file "<<Form("input/auau5_ks_fit_cut0_%s.txt",funcname[fswitch])<<endl;
	int parmsnumber = (fswitch) ? kParms : kParms2;
	Double_t* parmsarray = (fswitch) ? fitparms : fitparms2;
	for(int i=0;i<kCentBin;i++){
	   for(int j=0;j<parmsnumber;j++)parms>>parmsarray[i*parmsnumber+j];
	}
   }
   //modify the first parameter to compensate the scaling factor
   int parmsnumber = (fswitch) ? kParms : kParms2;
   Double_t* parmsarray = (fswitch) ? fitparms : fitparms2;
   for(int i=0;i<kCentBin;i++){
	parmsarray[i*parmsnumber] /= pow(10,i-kCentBin+1);
   }

   //histograms
   TString Dir("histo/");
   TString Name;
   if(!expswitch) Name="mck0sfp";
   else Name="mck0sexp";
   TFile ohm(Dir+Name+Form("%d",nlist)+".cut0."+Form("%s",funcname[fswitch])+".histo.root","recreate");

   TH1F * hDays = new TH1F("Days","Days",1000,0,1000.0);
   TH1F * hMag = new TH1F("Mag","Magnetic Field",8000,-10,10.0);
   TH2F * hCirate = new TH2F("Cirate","Coincident rate (zdc vs bbc)",500,0,3000,500,0,30000);

   Double_t nEvCount[kCentBin];
   Double_t nMcCount[kCentBin];
   Double_t wMcCount[kCentBin][kPtBin];
   Double_t wRcCount[kCentBin][kPtBin];
   Double_t wRcOutCount[kCentBin][kPtBin];
   Double_t w2McCount[kCentBin][kPtBin];
   Double_t w2RcCount[kCentBin][kPtBin];
   Double_t w2RcOutCount[kCentBin][kPtBin];

   Float_t pdgmass = 0.497614;
   Float_t masswidth = 0.2208;

   TH1F * hSelectVz = new TH1F( "SelectVz", "Vertex Z of selected events", 1000, -70, 70.0 ) ;
   TH1F * hmVz[kCentBin];
   for(Int_t iIM=0; iIM<kCentBin; iIM++){
	TString hName("hmVz");
	hName = hName + "Cent" + Form("%d",iIM);
	TString hTitle("Vertex Z");
	hTitle = hTitle + " for centrality bin " + Form("%d",iIM);
	hmVz[iIM] = new TH1F(hName, hTitle, 700,-70,70);
   }
   
   TH1F * hmIM[kCentBin][kPtBin];
   TH1F * hmMcPt[kCentBin][kPtBin];
   TH1F * hmMcPtCent[kCentBin];
   TH1F * hmMcPtNoWgtCent[kCentBin];
   TH1F * hmIMCent[kCentBin];
   for(Int_t iIM=0; iIM<kCentBin; iIM++){
	TString hName("hmInvMass");
	TString hTitle("Invariant mass for ");
	hName = hName + "Cent" + Form("%d",iIM);
	hTitle = hTitle + "centrality bin " + Form("%d",iIM);
	hmIMCent[iIM] = new TH1F(hName, hTitle, 552, pdgmass-masswidth, pdgmass+masswidth);
	hmIMCent[iIM]->Sumw2();
	hmMcPtCent[iIM] = new TH1F(Form("hmMcPt%d",iIM),Form("Mc Pt for centrality bin %d",iIM),200,0,10.0);
	hmMcPtNoWgtCent[iIM] = new TH1F(Form("hmMcPtNoWgt%d",iIM),Form("Mc Pt NoWgt for centrality bin %d",iIM),200,0,10.0);
	nEvCount[iIM]=0;
	nMcCount[iIM]=0;
	for(Int_t jIM=0; jIM<kPtBin; jIM++){
	   TString hName("hmInvMass");
	   TString hTitle("Invariant mass for ");
	   hName = hName + "Cent" + Form("%d",iIM) + "Pt" + Form("%d",jIM);
	   hTitle = hTitle + "centrality bin " + Form("%d",iIM) + " pt bin " + Form("%d",jIM);
	   hmIM[iIM][jIM] = new TH1F(hName, hTitle, 552, pdgmass-masswidth, pdgmass+masswidth);

	   hmIM[iIM][jIM]->Sumw2();

	   hName = hName + "McPt";
	   hTitle = hTitle + "McPt";
	   hmMcPt[iIM][jIM] = new TH1F(hName, hTitle, 320,0,8.0);
	   hmMcPt[iIM][jIM]->Sumw2();

	   wMcCount[iIM][jIM]=0;
	   wRcCount[iIM][jIM]=0;
	   wRcOutCount[iIM][jIM]=0;
	   w2McCount[iIM][jIM]=0;
	   w2RcCount[iIM][jIM]=0;
	   w2RcOutCount[iIM][jIM]=0;
	}
   }

   TH1F * hmNhitNfit = new TH1F("hmNhitNfit","Nhit - Nfit", 100,-50 ,50);

   TH2F * hmRcPtMcPt;
   hmRcPtMcPt = new TH2F("hmRcPtMcPt","pT (RC vs MC)", 200,0,7,200,0,7);
   TH1F * hmIMcheck = new TH1F("hmIMcheck","check inv mass", 552, pdgmass-masswidth, pdgmass+masswidth);
 
   //histogram for cent bin and pt bin
   TH1D * hmGroup = new TH1D("hmGroup","Run Group finder",kGroup,grpbd);
   TH1D * hmCent[kGroup];
   for(Int_t i=0;i<kGroup;i++){
	for(int j=0;j<kCentBin;j++)centbd[i][j] -= 0.1;
      TString hName("hmCent");
      hName = hName + Form("%d",i);
      TString hTitle("Centrality bin finder for group ");
      hTitle = hTitle + Form("%d",i);
      hmCent[i] = new TH1D(hName,hTitle,kCentBin,centbd[i]);
	hmCent[i]->Sumw2();
   }
   TH1F * hmPt = new TH1F("hmPt","Pt bin finder",kPtBin,ptbd);

   int mcidvec[200];

   int nfound=0;
   int rcmcidvec[200];
   
   //event loop (copy from wrapper class' Loop method)
   Long64_t nentries = t->GetEntriesFast();
   Long64_t nbytes = 0, nb = 0;
   for (Long64_t jentry=0; jentry<nentries;jentry++) {
	Long64_t ientry = dst.LoadTree(jentry);
	if (ientry < 0) break;
	nb = t->GetEntry(jentry);   nbytes += nb;

	if(jentry%10000==0)cout<<jentry<<" "<<nentries<<endl;

	nfound=0;

	//refmultCorrUtil->init(dst.runnumber);
	//if ( refmultCorrUtil->isBadRun(dst.runnumber) ) continue;

	//if(fabs(dst.primvertexX*dst.primvertexX+dst.primvertexY*dst.primvertexY)>4.0)continue;
	//if(fabs(dst.primvertexZ)>70)continue;
	//if(fabs(dst.ntofmatched)<2.0)continue;

	//refmultCorrUtil->initEvent(dst.nrefmult, dst.primvertexZ) ;

	hDays->Fill((dst.runnumber%1000000)/1000);
	hMag->Fill(dst.magn);
	hCirate->Fill(dst.zdccirate,dst.bbccirate);
	hSelectVz->Fill(dst.primvertexZ);

	//find group
	Int_t grp = hmGroup->FindBin(dst.runnumber)-1;
      //cout<<dst.runnumber<<" "<<grp<<endl;
      hmGroup->Fill(dst.runnumber);
      if(grp<0 || grp >= kGroup) continue;

	//find centbin
      //Int_t centbin = hmCent[grp]->FindBin(refmultCorrUtil->getCentralityBin9())-1;
	Int_t centbin = hmCent[grp]->FindBin(dst.nrefmult)-1;
      //hmCent[grp]->Fill(refmultCorrUtil->getCentralityBin9());
	hmCent[grp]->Fill(dst.nrefmult,1.0);
      if(centbin==kCentBin){cout<<"ERROR in StRefMultCorr!"<<endl; break;}

	if(centbin>=0)hmVz[centbin]->Fill(dst.primvertexZ);
	nEvCount[centbin] += 1;

	/*
	float mcpt[100]={0};
	float mcy[100]={0};
	float mcphi[100]={0};
	*/
	//loop MC v0's
	for(Int_t i=0;i<dst.nmcv0;i++){
	   mcidvec[i] = dst.mcv0id[i];
	   /*
	   mcpt[i] = dst.mcv0pt[i];
	   mcy[i] = dst.mcv0rapidity[i];
	   mcphi[i] = atan2(dst.mcv0py[i],dst.mcv0px[i]);
	   */
	   if(dst.mcv0rapidity[i]<-1.75)continue;
	   if(dst.mcv0rapidity[i]>-1.50)continue;
	   if(centbin<0)continue;
	   Int_t ptbin = hmPt->FindBin(dst.mcv0pt[i])-1;
	   if(ptbin==kPtBin)ptbin = -1;
	   Double_t wgt = getWeight(centbin, dst.mcv0pt[i], expswitch);
	   hmMcPtCent[centbin]->Fill(dst.mcv0pt[i],wgt);
	   hmMcPtNoWgtCent[centbin]->Fill(dst.mcv0pt[i]);
	   nMcCount[centbin] += 1;
	   if(centbin<0 || ptbin<0)continue;
	   wMcCount[centbin][ptbin] += wgt; 
	   w2McCount[centbin][ptbin] += wgt*wgt; 
	}
	
	//loop RC v0's
	for(Int_t i=0;i<dst.nv0;i++){

	   hmNhitNfit->Fill(dst.dau1nhits[i]-dst.dau1tpc[i]);

	   //cuts
	   if(dst.v0rapidity[i]<-1.75)continue;
	   if(dst.v0rapidity[i]>-1.50)continue;

	   if(dst.v0declen[i]<2.7)continue;
	   if(dst.dau1dca[i]<1.3)continue;
	   if(dst.dau2dca[i]<1.3)continue;
	   if(dst.v0dca[i]>0.8)continue;
	   if(dst.dca1to2[i]>1.5)continue;
	   if(dst.dau1nhits[i]<=10)continue;
	   if(dst.dau2nhits[i]<=10)continue;            
	   if(dst.dau1pt[i]<0.12)continue;
	   if(dst.dau2pt[i]<0.12)continue;
	   if(fabs(dst.dau1nsigma[i])>4.0)continue;
	   if(fabs(dst.dau2nsigma[i])>4.0)continue;
	   if(1.0*dst.dau1nhits[i]/dst.dau1nhitsposs[i]<0.0)continue;
	   if(1.0*dst.dau2nhits[i]/dst.dau2nhitsposs[i]<0.0)continue;
	   if(dst.dau1nhitsdedx[i]<0)continue;
	   if(dst.dau2nhitsdedx[i]<0)continue;

	   if(1.0*dst.dau1ncommhits[i]/dst.dau1nhits[i]<0.0)continue;
	   if(1.0*dst.dau2ncommhits[i]/dst.dau2nhits[i]<0.0)continue;

	   /*
	   float p1=sqrt(dst.dau1pt[i]*dst.dau1pt[i]+dst.dau1pz[i]*dst.dau1pz[i]);
	   float p2=sqrt(dst.dau2pt[i]*dst.dau2pt[i]+dst.dau2pz[i]*dst.dau2pz[i]);
	   float dau1eta=0.5*log((p1+dst.dau1pz[i])/(p1-dst.dau1pz[i]));
	   float dau2eta=0.5*log((p2+dst.dau2pz[i])/(p2-dst.dau2pz[i]));
	   if(fabs(dau1eta)>1.0)continue;
	   if(fabs(dau2eta)>1.0)continue;

	   if(dst.dau1flag[i]<=0)continue;
	   if(dst.dau2flag[i]<=0)continue;
	   */

	   StThreeVectorF PV(dst.primvertexX,dst.primvertexY,dst.primvertexZ);
	   StThreeVectorF xv0(dst.v0x[i],dst.v0y[i],dst.v0z[i]);
	   StThreeVectorF pv0(dst.v0px[i],dst.v0py[i],dst.v0pz[i]);
	   StPhysicalHelixD helixv0(pv0,xv0,0,0);
	   StThreeVectorF xv0toPV = xv0 - PV;
	   double rdotp = xv0toPV.dot(pv0) ;
	   //if(rdotp<=0)continue;
	   if(rdotp<=0)continue;

	   //veto lambda and Xi (proton from Lambda + bachelor pi-)
	   double mMass1=0.93827;
	   double mMass2=0.13957;
	   double oe1 = sqrt(dst.dau1px[i]*dst.dau1px[i]+dst.dau1py[i]*dst.dau1py[i]+dst.dau1pz[i]*dst.dau1pz[i]+ mMass1*mMass1);
	   double oe2 = sqrt(dst.dau2px[i]*dst.dau2px[i]+dst.dau2py[i]*dst.dau2py[i]+dst.dau2pz[i]*dst.dau2pz[i]+ mMass2*mMass2);
	   double v0mass1 = sqrt(mMass1*mMass1 + mMass2*mMass2 + 2.*oe1*oe2 - 2.*(dst.dau1px[i]*dst.dau2px[i]+dst.dau1py[i]*dst.dau2py[i]+dst.dau1pz[i]*dst.dau2pz[i]));
	   //if(fabs(v0mass1-1.1157)<0.015)continue;
	   //if(v0mass1>1.1157-0.01 && v0mass1<1.165)continue;
	   if(v0mass1>1.1057 && v0mass1<1.165)continue;
	   mMass1=0.13957;
	   mMass2=0.93827;
	   oe1 = sqrt(dst.dau1px[i]*dst.dau1px[i]+dst.dau1py[i]*dst.dau1py[i]+dst.dau1pz[i]*dst.dau1pz[i]+ mMass1*mMass1);
	   oe2 = sqrt(dst.dau2px[i]*dst.dau2px[i]+dst.dau2py[i]*dst.dau2py[i]+dst.dau2pz[i]*dst.dau2pz[i]+ mMass2*mMass2);
	   double v0mass2 = sqrt(mMass1*mMass1 + mMass2*mMass2 + 2.*oe1*oe2 - 2.*(dst.dau1px[i]*dst.dau2px[i]+dst.dau1py[i]*dst.dau2py[i]+dst.dau1pz[i]*dst.dau2pz[i]));
	   //if(fabs(v0mass2-1.1157)<0.015)continue;
	   //if(v0mass2>1.1157-0.01 && v0mass2<1.165)continue;
	   if(v0mass2>1.1057 && v0mass2<1.165)continue;

	   //find the MC v0 index according to their ids
	   int ind = -1;
	   for(int ik=0;ik<dst.nmcv0;ik++)
		if(mcidvec[ik]==dst.v0mcid[i]){ind = ik; break;}

	   for(int ifd=0;ifd<nfound;ifd++)
	   {
		if(rcmcidvec[ifd]==dst.v0mcid[i])cout<<dst.v0mcid[i]<<" double!!!"<<endl;
	   }
	   rcmcidvec[nfound]=dst.v0mcid[i];
	   nfound++;

	   hmRcPtMcPt->Fill(dst.v0pt[i],dst.mcv0pt[ind]);

	   /*
	   //found bad association
	   bool badmatch =  false;
	   double phasediff = sqrt((dst.v0px[i]-dst.mcv0px[ind])*(dst.v0px[i]-dst.mcv0px[ind])+(dst.v0py[i]-dst.mcv0py[ind])*(dst.v0py[i]-dst.mcv0py[ind])+(dst.v0pz[i]-dst.mcv0pz[ind])*(dst.v0pz[i]-dst.mcv0pz[ind]));
	   for(int kk=0;kk<dst.nmcv0;kk++){
		double phasediff1 = sqrt((dst.v0px[i]-dst.mcv0px[kk])*(dst.v0px[i]-dst.mcv0px[kk])+(dst.v0py[i]-dst.mcv0py[kk])*(dst.v0py[i]-dst.mcv0py[kk])+(dst.v0pz[i]-dst.mcv0pz[kk])*(dst.v0pz[i]-dst.mcv0pz[kk]));
		if(kk!=ind && phasediff1<phasediff){
		   cout<<"Mismatch 1 !"<<endl;
		   cout<<"RC: "<<dst.v0px[i]<<" "<<dst.v0py[i]<<" "<<dst.v0pz[i]<<" "<<dst.v0mass[i]<<endl;
		   cout<<"MC1: "<<dst.mcv0px[kk]<<" "<<dst.mcv0py[kk]<<" "<<dst.mcv0pz[kk]<<endl;
		   cout<<"MC2: "<<dst.mcv0px[ind]<<" "<<dst.mcv0py[ind]<<" "<<dst.mcv0pz[ind]<<endl;
		}
	   }

	   //algorithm2
	   bool badassoc = false;
	   //if(!expswitch && fabs(dst.v0pt[i]-dst.mcv0pt[ind])>dst.mcv0pt[ind]*0.1) {
	   if(fabs(dst.v0pt[i]-dst.mcv0pt[ind])>dst.mcv0pt[ind]*0.1) {
		for(int kk=0;kk<dst.nmcv0;kk++){
		   if( kk!=ind && fabs(mcy[kk]-dst.v0rapidity[i])<0.15 && fabs(mcphi[kk]-atan2(dst.v0py[i],dst.v0px[i]))<0.15) {
			cout<<"Mismatch!"<<endl;
			badassoc = true;
		   cout<<"RC: "<<dst.v0px[i]<<" "<<dst.v0py[i]<<" "<<dst.v0pz[i]<<endl;
		   cout<<"MC1: "<<dst.mcv0px[kk]<<" "<<dst.mcv0py[kk]<<" "<<dst.mcv0pz[kk]<<endl;
		   cout<<"MC2: "<<dst.mcv0px[ind]<<" "<<dst.mcv0py[ind]<<" "<<dst.mcv0pz[ind]<<endl;
		   }
		}
	   }
	   //if(badassoc)continue;

	   if((dst.v0pt[i]-dst.mcv0pt[ind])>0.25*dst.mcv0pt[ind]){
		cout<<"XXXXXXXXX"<<endl;
		cout<<"RC: "<<dst.v0pt[i]<<" "<<dst.v0rapidity[i]<<" "<<dst.v0px[i]<<" "<<dst.v0py[i]<<" "<<dst.v0pz[i]<<" "<<dst.v0mass[i]<<endl;
		cout<<"MC: "<<dst.mcv0pt[ind]<<" "<<dst.mcv0rapidity[ind]<<" "<<dst.mcv0px[ind]<<" "<<dst.mcv0py[ind]<<" "<<dst.mcv0pz[ind]<<endl;
		cout<<"ZZZZZZZZZ"<<endl;
		hmIMcheck->Fill(dst.v0mass[i]);
		continue;
	   }
	   */

	   //fill histograms
	   if(centbin>=0)hmIMCent[centbin]->Fill(dst.v0mass[i]);
	   Int_t ptbin = hmPt->FindBin(dst.v0pt[i])-1;
	   if(ptbin==kPtBin)ptbin = -1;
	   if(centbin<0 || ptbin<0)continue;

	   if(dst.mcv0pt[ind]<ptbd[ptbin]*0.8)continue; //a simple way to remove the outliers, the number should be tuned for each kind of particle
	   
	   Double_t wgtrc = getWeight(centbin, dst.mcv0pt[ind], expswitch);
	   hmIM[centbin][ptbin]->Fill(dst.v0mass[i],wgtrc);
	   hmMcPt[centbin][ptbin]->Fill(dst.mcv0pt[ind],wgtrc);
	   Int_t mcptbin = hmPt->FindBin(dst.mcv0pt[ind])-1;
	   if(mcptbin == ptbin){
		wRcCount[centbin][ptbin] += wgtrc;
		w2RcCount[centbin][ptbin] += wgtrc*wgtrc;
	   }
	   else{
		wRcOutCount[centbin][ptbin] += wgtrc;
		w2RcOutCount[centbin][ptbin] += wgtrc*wgtrc;
	   }
	}
   }

   TString ofilename;
   if(!expswitch) ofilename=Form("output/weight_k0s_cut0_%s_fp.txt",funcname[fswitch]);
   else ofilename=Form("output/weight_k0s_cut0_%s_exp.txt",funcname[fswitch]);
   ofstream oweight(ofilename);
   
   for(int i=0;i<kCentBin;i++)
	for(int j=0;j<kPtBin;j++){
	   wMcCount[i][j] /= nMcCount[i]/nEvCount[i];
	   wRcCount[i][j] /= nMcCount[i]/nEvCount[i];
	   wRcOutCount[i][j] /= nMcCount[i]/nEvCount[i];
	   w2McCount[i][j] /= (nMcCount[i]/nEvCount[i])*(nMcCount[i]/nEvCount[i]);
	   w2RcCount[i][j] /= (nMcCount[i]/nEvCount[i])*(nMcCount[i]/nEvCount[i]);
	   w2RcOutCount[i][j] /= (nMcCount[i]/nEvCount[i])*(nMcCount[i]/nEvCount[i]);

	   Float_t eff = (wRcCount[i][j]+wRcOutCount[i][j])/wMcCount[i][j];
	   Float_t wRcNoCount = wMcCount[i][j]-wRcCount[i][j];
	   Float_t w2RcNoCount = w2McCount[i][j]-w2RcCount[i][j];
	   Float_t efferr = sqrt(w2RcCount[i][j]*(wRcNoCount-wRcOutCount[i][j])*(wRcNoCount-wRcOutCount[i][j])+w2RcNoCount*(wRcCount[i][j]+wRcOutCount[i][j])*(wRcCount[i][j]+wRcOutCount[i][j])+w2RcOutCount[i][j]*wMcCount[i][j]*wMcCount[i][j])/wMcCount[i][j]/wMcCount[i][j];
	   cout<<i<<" "<<j<<" "<<wMcCount[i][j]<<" "<<wRcCount[i][j]<<" "<<wRcOutCount[i][j]<<" "<<w2McCount[i][j]<<" "<<w2RcCount[i][j]<<" "<<w2RcOutCount[i][j]<<" "<<eff<<" "<<efferr/eff<<endl;
	   oweight<<i<<" "<<j<<" "<<wMcCount[i][j]<<" "<<wRcCount[i][j]<<" "<<w2McCount[i][j]<<" "<<w2RcCount[i][j]<<" "<<eff<<" "<<efferr/eff<<endl;
	}

   oweight.close();

   //output the details
   TString ofile2name;
   if(!expswitch) ofile2name=Form("output/weight_k0s_cut0_%s_fp_appd.txt",funcname[fswitch]);
   else ofile2name=Form("output/weight_k0s_cut0_%s_exp_appd.txt",funcname[fswitch]);
   ofstream oweight2(ofile2name);

   for(int i=0;i<kCentBin;i++)
	for(int j=0;j<kPtBin;j++){
	   oweight2<<i<<" "<<j<<" "<<wMcCount[i][j]<<" "<<wRcCount[i][j]<<" "<<wRcOutCount[i][j]<<" "<<w2McCount[i][j]<<" "<<w2RcCount[i][j]<<" "<<w2RcOutCount[i][j]<<endl;
	}

   oweight2.close();

   ohm.Write();	//save all booked histograms
   ohm.Close();
   delete t;
}

Double_t getWeight(Int_t cent, Float_t pt, int expswitch){
   Double_t wgt;

   funclowpt.SetParameters(&fitparms[cent*kParms]);

   if (funcswitch) wgt = funclowpt.Eval(pt);

   funchighpt.SetParameters(&fitparms2[cent*kParms2]);

   if (!funcswitch) wgt = funchighpt.Eval(pt);

   if(expswitch)wgt = wgt*exp(pt/0.35)/pt;

   return wgt;
}
